思路：题意是戳一个气球，然后把这个气球和它的左右两个气球乘一起，直到没有气球为止的最大值。倒放这一过程，我们可以把题意转化为添加一个气球，把这个气球和它的左右两个气球乘一起，直到数组添加完成的最大值。由于倒放没有改变每个气球的两侧元素，所以答案不变。
1 1 1 1
0 1 1 1
0 1 0 1
0 1 0 0
0 0 0 0
倒放：
0 0 0 0
0 1 0 0
0 1 0 1
0 1 1 1
1 1 1 1
我们在区间[l,r]内选择一个位置**i**添加气球，添加完成后，剩下还需要添加的气球的位置就是[l,i-1]和[i+1,r]。我们还可以发现，一个气球的左右两侧气球是左右端点外的那两个气球，i与两个端点中间是没有气球的，中间的部分会继续递归下去，直到l和r中间没有任何气球需要添加。
递归入口：[0, n-1],表示一个闭区间。
时间复杂度:

> $O(n^3)$

# Code

* []

```Python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        n = len(nums)
        nums = [1] + nums + [1]
        # @cache
        # def solve(left: int, right: int) -> int:
        #     if left > right:
        #         return 0
        #     best = 0
        #     for i in range(left, right+1):
        #         total = nums[left-1] * nums[i] * nums[right+1]
        #         total += solve(left, i-1) + solve(i+1, right)
        #         best = max(best, total)
        #     return best
        # return solve(0, n-1) 
        f=[[0]*(n+1) for _ in range(n+1)]
        for l in range(n-1,-1,-1):
            for r in range(l,n):
                for i in range(l,r+1):
                    f[l][r]=max(f[l][r],f[l][i-1]+f[i+1][r]+nums[l-1] * nums[i] * nums[r+1])
        return f[0][n-1]
```


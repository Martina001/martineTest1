> Problem: [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)

[TOC]

# 背包问题

- 01背包问题：每种物品只有一个
- 完全背包问题：每种物品有无数个

## 1. 01背包

- 写出纯二维的01背包
- 两个for循环嵌套顺序？反过来可以吗？
- 初始化的逻辑
- 写出纯一维的01背包
- 两个for循环嵌套顺序？反过来可以吗？
- 初始化的逻辑

### 二维数组

#### 思路分析

动规五部曲：

- dp\[i][j]的含义：从下标为0-i的所有物品中选取任意个物品放入一个容量为j的背包，背包所背物品的最大价值。

- 递推公式：

  - 不取当前物品 dp\[i][jj] = dp\[i-1][j]
  - 取当前物品 dp\[i][j] = dp\[i-1][j-weight[i]] + val[i]

  综上 递推公式为dp\[i][j] = Math.max(dp\[i-1][j], dp\[i-1][j-weight[i]] + val[i])

- 初始化dp\[i][j]：

  由于dp\[i][j]取决于

  - dp\[i-1][j]
  - dp\[i-1][j-weight[i]]

  因此需要初始化第0行 和 第0列

  初始化第0行：当j >= weight[0]时 dp\[0][j] = val[0]；j < weight[0]时 dp\[0][j] = 0

  初始化第0列：背包容量为0是，所背物品最大价值一定是0，因为什么物品都放不下

  其他位置的初始化，由于dp\[i][j]的值完全由其左上方元素决定，因此初始化为任何值都可以。为方便起见，直接使用默认的0即可。

- 遍历顺序：

  由于dp\[i][j]取决于

  - dp\[i-1][j]
  - dp\[i-1][j-weight[i]]

  即dp\[i][j]取决于其上方和左上方的元素，因此只要保证是从上往下，从左往右遍历即可。

  外层遍历物品，内层遍历背包。或是外层遍历背包，内层遍历物品都是可以的。

- 举例推导：

  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | :---: | :--: | :--: |
  | 物品0 |  1   |  15  |
  | 物品1 |  3   |  20  |
  | 物品2 |  4   |  30  |

  递推公式：`dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + val[i])`

  外层遍历物品 内层遍历背包

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    | 15   | 15   | 15   | 15   |
  | 物品1 | 0    | 15   | 15   | 20   | 35   |
  | 物品2 | 0    | 15   | 15   | 20   | 35   |

  ​

  外层遍历背包 内层遍历物品

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    | 15   | 15   | 15   | 15   |
  | 物品1 | 0    | 15   | 15   | 20   | 35   |
  | 物品2 | 0    | 15   | 15   | 20   | 35   |

  可以发现无论是先遍历背包还是物品得到的dp数组都是一样的，因此两种方式都可以。

#### 实现代码

* java

```java
import java.util.*;
public class Main {
    /**
     * 三行输入
     * 1. 两个正整数 M物品的种类 背包容量为N
     * 2. M个整数 代表每种物品的重量
     * 3. M个整数 代表每种物品的价值
     * 
     * 输出背包所装物品的最大价值
     **/
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();
        int N = scanner.nextInt();
        int[] weight = new int[M];
        int[] val = new int[M];
        int[][] dp = new int[M][N + 1];

        for (int i = 0; i < M; i++) {
            weight[i] = scanner.nextInt();
        }
        for (int i = 0; i < M; i++) {
            val[i] = scanner.nextInt();
        }

        // 初始化第0行
        for (int j = weight[0]; j <= N; j++) {
            dp[0][j] = val[0];
        }
        // 初始化第0列 全部默认为0即可

        // 循环遍历
        for (int i = 1; i < M; i++) {
            for (int j = 1; j <= N; j++) {
                if (j >= weight[i]) {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + val[i]);
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        // 输出结果
        for (int i = 0; i < M; i++) {
            for (int j = 0; j <= N; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println(dp[M - 1][N]);
        /**
         * 输出结果
         * 0 15 15 15 15 
         * 0 15 15 20 35 
         * 0 15 15 20 35 
         * 35
         **/
    }
}
```

### 一维数组

#### 思路分析

二维数组的递推公式为：`dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + val[i])`

相当是把`i-1`行的数据复制到第`i`行，再执行`dp[i][j] = Math.max(dp[i][j], dp[i][j-weight[i]] + val[i])`

因此，可以降低为一维数组`dp[j] = Math.max(dp[j], dp[j-weight[i]] + val[i])`

动规五部曲：

- dp\[j]的含义：从下标为0-i的物品中选择任意物品，放入一个容量为j的背包，背包所背物品的最大价值

- 递推公式：`dp[j] = Math.max(dp[j], dp[j-weight[i]] + val[i])`

- 初始化dp[j]：

  由于dp\[i][j]取决于

  - dp[j]
  - dp[j-weight[i]]

  因此需要初始化dp[0]，dp[0] = 0 当背包容量为0时，所背物品最大价值为0

  其它位置的的初始化，即当i=0时，dp数组的初始化。可以发现，递推公式可以直接实现当i=0时对dp数组的初始化。

  因此无需手动初始化，在下面遍历循环的时候直接进行计算即可。

- 遍历顺序：

  由于dp[j]取决于

  - dp[j]---本质上是上一行的dp[j]
  - dp[j-weight[i]]---本质上是上一行的dp[j-weight[i]]

  因此需要**从上往下**遍历，**从右往左**遍历。

  从上往下遍历好理解，从右往左遍历是为什么。

  如果从左往右遍历，则会先处理dp[j-weight[i]]再处理dp[j]，即处理到dp[j]时，此时的dp[j-weight[i]]已经是这一行的dp[j-weight[i]]，而不是上一行的dp[j-weight[i]]。

  由于dp[j]是取决于上一行的dp[j-weight[i]]。因此，需要从右往左遍历，保证处理dp[j]时的dp[j-weight[i]]是上一层的dp[j-weight[i]]。

  ​

  **外层遍历物品 内层遍历背包**

  **不能外层遍历背包 内层遍历物品**，因为是从右往左遍历的，如果外层遍历背包，内层遍历物品，遍历到dp[j]时，上一行的dp[j-weight[i]]都还没有处理到。

  具体可以看下面的举例推导

- 举例推导：

  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | :---: | :--: | :--: |
  | 物品0 |  1   |  15  |
  | 物品1 |  3   |  20  |
  | 物品2 |  4   |  30  |

  递推公式：`dp[j] = Math.max(dp[j], dp[j-weight[i]] + val[i])`

  ​

  外层遍历物品 内层遍历背包

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    | 15   | 15   | 15   | 15   |
  | 物品1 | 0    | 15   | 15   | 20   | 35   |
  | 物品2 | 0    | 15   | 15   | 20   | 35   |

  ​

  外层遍历背包 内层遍历物品

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    |      |      |      | 15   |
  | 物品1 |      |      |      |      | ×    |
  | 物品2 |      |      |      |      |      |

  ×：第1行的dp[4]取决于第0行的dp[4]和第0行的dp[4-weight[1]]，即第0行的dp[4]和dp[1]。

  ​     由于第0行的dp[1]还没有遍历到，即第0行的dp[1]还不知道的，所以不能先计算×位置的值。因此**不能**外层遍历背包，内层遍历物品。

#### 实现代码

* java

```java
import java.util.*;
public class Main {
    /**
     * 三行输入
     * 1. 两个正整数 M物品的种类 背包容量为N
     * 2. M个整数 代表每种物品的重量
     * 3. M个整数 代表每种物品的价值
     * 
     * 输出背包所装物品的最大价值
     **/
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();
        int N = scanner.nextInt();
        int[] weight = new int[M];
        int[] val = new int[M];
        int[] dp = new int[N + 1];

        for (int i = 0; i < M; i++) {
            weight[i] = scanner.nextInt();
        }
        for (int i = 0; i < M; i++) {
            val[i] = scanner.nextInt();
        }

        // 初始化
        // dp[0] = 0;

        // 循环遍历
        for (int i = 0; i < M; i++) {
            for (int j = N; j >= weight[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + val[i]);
            }
            // 输出结果
            for (int j = 0; j <= N; j++) {
                System.out.print(dp[j] + " ");
            }
            System.out.println();
        }
        System.out.print(dp[N]);
        /**
         * 输出结果
         * 0 15 15 15 15 
         * 0 15 15 20 35 
         * 0 15 15 20 35 
         * 35
         **/
    }
}
```

​

## 2. 完全背包

- 写出纯二维的完全背包
- 两个for循环嵌套顺序？反过来可以吗？
- 初始化的逻辑
- 写出纯一维的完全背包
- 两个for循环嵌套顺序？反过来可以吗？
- 初始化的逻辑

### 二维数组

#### 思路分析

动态规划五部曲：

- dp\[i][j]的含义：从下标为0-i的物品选取任意物品放入容量为j的背包，所背物品的最大价值

- 递推公式：

  - 不放入物品i `dp[i][j] = dp[i - 1][j]`

  - 放入物品i
    - 第一次放入 `dp[i][j] = dp[i - 1][j - weight[i]] + val[i] = dp[i][j - weight[i]] + val[i]` （由于在j列是第一次放入，因此在`j-weight[i]`列时并没有放入物品i，因此`dp[i][j - weight[i]] =  dp[i - 1][j - weight[i]]）`
    - 非第一次放入 `dp[i][j] = dp[i][j - weight[i]] + val[i]`

    综上，放入物品i时`dp[i][j] = dp[i][j - weight[i]] + val[i]`

    故递推公式为：`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])`

- 初始化dp\[i][j]：

  由于dp\[i][j]取决于

  - dp\[i - 1][j]
  - dp\[i][j - weight[i]]

  因此需要初始化第0行和第0列

  初始化第0行，当`i==0`时，`dp[0][j] = (j/weight[0]) * val[i]`，即尽可能地放多个物品0

  初始化第0列，当`j==0`时，`dp[i][0] = 0`，背包容量为0。

  其他部分的初始化，默认为0即可。

- 遍历顺序

  由于dp\[i][j]取决于

  - dp\[i - 1][j]
  - dp\[i][j - weight[i]]

  因此需要从上往下，从左往右遍历

  先遍历物品再遍历背包 或是 先遍历背包再遍历物品都可以

  只要保证是从上往下，从左往右遍历即可

- 举例推导

  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | :---: | :--: | :--: |
  | 物品0 |  1   |  15  |
  | 物品1 |  3   |  20  |
  | 物品2 |  4   |  30  |

  递推公式：`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])`

  ​

  外层遍历物品 内层遍历背包

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    | 15   | 30   | 45   | 60   |
  | 物品1 | 0    | 15   | 30   | 45   | 60   |
  | 物品2 | 0    | 15   | 30   | 45   | 60   |

  ​

  外层遍历背包 内层遍历物品

  |       | 0    | 1    | 2    | 3    | 4    |
  | ----- | ---- | ---- | ---- | ---- | ---- |
  | 物品0 | 0    | 15   | 30   | 45   | 60   |
  | 物品1 | 0    | 15   | 30   | 45   | 60   |
  | 物品2 | 0    | 15   | 30   | 45   | 60   |

#### 代码实现

* java

```java
import java.util.*;
public class Main {
    /**
     * 
     * 1. 1行输入 两个正整数 M物品的种类 背包容量为N
     * 2. M行输入 每行两个整数wi vi
     *    wi代表第i种材料的重量
     *    vi代表第i种材料的价值
     * 
     * 输出背包所装物品的最大价值
     **/
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        int[] weight = new int[m];
        int[] val = new int[m];
        int[][] dp = new int[m][n + 1];

        for (int i = 0; i < m; i++) {
            weight[i] = scanner.nextInt();
            val[i] = scanner.nextInt();
        }

        // 初始化dp
        // 初始化第0行
        for (int j = 0; j <= n; j++) {
            dp[0][j] = (j / weight[0]) * val[0];
        }
        // 初始化第0列
        // 全部为0即可

        // 循环遍历
        for (int i = 1; i < m; i++) {
            for (int j = 1; j <= n; j++) {
                if (j >= weight[i]) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + val[i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // 输出结果
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= n; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        System.out.print(dp[m - 1][n]);
    }
}
```

### 一维数组

#### 思路分析

动规五部曲：

- dp[j]的含义：容量为j的背包所背物品的最大价值

- 递推公式：

  二维数组的递推公式为：`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])`

  相当于把第i-1行复制到第i行，再从左往右计算dp\[i][j]。则遍历到第j列时，dp\[i][j]还是第i-1行的值（即为`dp[i - 1][j]`），而`dp[i][j - weight[i]]`已经是第i行的值。

  所以只需要一维数组的递推公式即为：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + val[i])`

- 初始化dp[j]：

  由于dp[j]取决于

  - dp[j]
  - dp[j - weight[i]]

  因此需要初始化整个dp数组。

  dp[0] = 0

  其它位置的初始化：dp[j] = (j/weight[0]) * val[0]，由于递推公式达到初始化相同的效果，因此无需专门初始化，全部默认为0即可

- 遍历顺序：

  由于dp[j]取决于

  - dp[j]---本质为第i-1行的dp[j]
  - dp[j - weight[i]]---本质为第i行的dp[j-weight[i]]

  因此需要从上往下 从左往右进行遍历

  先遍历物品再遍历背包 或是 先遍历背包再遍历物品都可以【**下面有解释为什么两种方式都可以**】

  只要保证是从上往下，从左往右遍历即可

- 举例推导：
  - 背包最大重量为4。

    物品为：

    |       | 重量 | 价值 |
    | :---: | :--: | :--: |
    | 物品0 |  1   |  15  |
    | 物品1 |  3   |  20  |
    | 物品2 |  4   |  30  |

    递推公式：`dp[j] = Math.max(dp[j], dp[j - weight[i]] + val[i])`

    ​

    外层遍历物品 内层遍历背包

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 0    | 15   | 30   | 45   | 60   |
    | 物品1 | 0    | 15   | 30   | 45   | 60   |
    | 物品2 | 0    | 15   | 30   | 45   | 60   |

    ​

    外层遍历背包 内层遍历物品

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 0    | 15   | 30   | 45   | 60   |
    | 物品1 | 0    | 15   | 30   | 45   | 60   |
    | 物品2 | 0    | 15   | 30   | 45   | 60   |

#### 代码实现

* java

```java
import java.util.*;
public class Main {
    /**
     * 
     * 1. 1行输入 两个正整数 M物品的种类 背包容量为N
     * 2. M行输入 每行两个整数wi vi
     *    wi代表第i种材料的重量
     *    vi代表第i种材料的价值
     * 
     * 输出背包所装物品的最大价值
     **/
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        int[] weight = new int[m];
        int[] val = new int[m];
        int[] dp = new int[n + 1];

        for (int i = 0; i < m; i++) {
            weight[i] = scanner.nextInt();
            val[i] = scanner.nextInt();
        }

        // 初始化dp
        // 全部默认为0即可
        
        // 循环遍历
        for (int i = 0; i < m; i++) {
            for (int j = weight[i]; j <= n; j++) {
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + val[i]);
            }

            // 输出结果
            for (int j = 0; j <= n; j++) {
                System.out.print(dp[j] + " ");
            }
            System.out.println();
        }
       
        System.out.print(dp[n]);
    }
}
```

#### 为什么先遍历背包 或 先遍历物品都可以

- 如果是**先遍历物品**再遍历背包的：dp[j]可以理解为从**物品0-i**中选择任意物品放入容量为j的背包，背包所装物品的最大价值
- 如果是**先遍历背包**再遍历物品的：dp[j]可以理解为从**所有物品**中选择任意物品放入容量为j的背包，背包所装物品的最大价值

这两种方式遍历结束最后得到的结果**都是从所有物品中**选择任意物品放入容量为j的背包，背包所装物品的最大价值

因此两种遍历方式都是可以的。

## 3. 求恰好装满背包的方式数

问题描述：

背包容量为N，有M个物品，物品重量为weight[i]，求恰好将背包装满的方式数

### 组合数

#### 二维数组

##### 思路分析

动态规划五部曲：

- dp\[i][j]的含义：选择下标为0-i的任意若干物品，放入容量为j的背包，恰好装满容背包方式数

- 递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]`

- 初始化dp\[i][j]：

  由于dp\[i][j]取决于

  - `dp[i - 1][j]`
  - `dp[i][j - weight[i]]`

  因此需要初始化第0行和第0列

  初始化第0行：当`j % weight[0] == 0`时，dp\[0][j] = 1

  初始化第0列：dp\[i][0] = 1 什么都不放是一种方式

  其它位置的初始化：由于`dp[i][j]`取决于其左边和上方的元素，所以不管初始化为任何值都会被其左边和上方的值覆盖，因此为方便起见，默认初始化为0即可。

- 遍历顺序：

  由于dp\[i][j]取决于

  - `dp[i - 1][j]` ---》 从上往下遍历
  - `dp[i][j - weight[i]]` ----》从左往右遍历

  可以先遍历物品 也可以先遍历背包 只要是从上往下、从左往右遍历即可

- 举例推导：
  - 背包容量为4

  - 物品的重量：

    | 物品  | 重量 |
    | ----- | ---- |
    | 物品0 | 1    |
    | 物品1 | 2    |
    | 物品2 | 3    |

    递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]`

    ​

    先遍历物品 后遍历背包

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 1    | 1    |
    | 物品1 | 1    | 1    | 2    | 2    | 3    |
    | 物品2 | 1    | 1    | 2    | 3    | 4    |

    先遍历背包 后遍历物品

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 1    | 1    |
    | 物品1 | 1    | 1    | 2    | 2    | 3    |
    | 物品2 | 1    | 1    | 2    | 3    | 4    |

##### 代码实现

[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

* java

```java
/**
 * 转化为完全背包问题：
 * 背包的容量：amount
 * 物品的重量：coins[i]
 * 问物品能恰好将背包装满的方式数
 * 动规五部曲：
 * 1. dp[i][j]的含义：从物品0-i种选择任意物品放入背包 求恰好将背包装满的方式数
 * 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j - coins[i]]
 * 3. 初始化：初始化第0行 dp[0][j] = 1 if (j % coins[0] == 0)
 *           初始化第0列 dp[i][0] = 1什么都不放是一种方式
 * 4. 遍历顺序：从上往下 从左往右
 * 4. 举例推导
 **/
public int change(int amount, int[] coins) {
    int m = coins.length;
    int n = amount;
    int[][] dp = new int[m][n + 1];
    // 初始化第0行
    for (int j = 0; j <= n; j++) {
        if (j % coins[0] == 0) {
            dp[0][j] = 1;
        }
    }
    // 初始化第0列
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }

    // 循环遍历
    for (int i = 1; i < m; i++) {
        for (int j = 1; j <= n; j++) {
            if (j >= coins[i]) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    // 输出结果
    for (int i = 0; i < m; i++) {
        for (int j = 0; j <= n; j++) {
            System.out.print(dp[i][j] + " ");
        }
        System.out.println();
    }

    return dp[m - 1][n];
}
```

#### 一维数组

##### 思路分析

动态规划五部曲：

- dp[j]的含义：选择下标为0-i的任意若干物品，放入容量为j的背包，恰好装满容背包方式数

- 递推公式：

  二维数组的递推公式为：`dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]`

  因此一维数组的递推公式为`dp[j] = dp[j] + dp[j - weight[i]]`

- 初始化dp[j]：

  由于dp\[j]取决于

  - `dp[j]`
  - `dp[j - weight[i]]`

  因此需要初始化整个dp[j]数组

  初始化第0列：dp\[0] = 1 什么都不放是一种方式

  其他位置的初始化：当`j % weight[0] == 0`时，dp\[0][j] = 1，递推公式可以达到相同的效果，所以无需专门初始化，在循环遍历中统一实现即可。

- 遍历顺序：

  由于dp\[j]取决于

  - `dp[j]` ---》本质上是上一行的dp[j]，因此从上往下遍历
  - `dp[j - weight[i]]` ----》本质上是当前行的`dp[j - weight[i]]` ，因此从左往右遍历

  必须先遍历物品，后遍历背包，因为要保证遍历到dp[j]时的`dp[j - weight[i]]`是当前行的`dp[j - weight[i]]`。

- 举例推导：
  - 背包容量为4

  - 物品的重量：

    | 物品  | 重量 |
    | ----- | ---- |
    | 物品0 | 1    |
    | 物品1 | 2    |
    | 物品2 | 3    |

    递推公式：`dp[j] = dp[j] + dp[j - weight[i]]`

    先遍历物品 后遍历背包

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 1    | 1    |
    | 物品1 | 1    | 1    | 2    | 2    | 3    |
    | 物品2 | 1    | 1    | 2    | 3    | 4    |

    先遍历背包 后遍历物品 ==**错误做法**==

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 2    | 4    |
    | 物品1 | 1    | 1    | 2    | 3    | 6    |
    | 物品2 | 1    | 1    | 2    | 4    | 7    |

##### 代码实现

* java

```java
class Solution {
    /**
     * 转化为完全背包问题：
     * 背包的容量：amount
     * 物品的重量：coins[i]
     * 问物品能恰好将背包装满的方式数
     * 动规五部曲：
     * 1. dp[j]的含义：从物品0-i种选择任意物品放入背包 求恰好将背包装满的方式数
     * 2. 递推公式：dp[j] = dp[j] + dp[j - coins[i]]
     * 3. 初始化：初始化第0行 在循环遍历中执行即可
     *           初始化第0列 dp[0] = 1什么都不放是一种方式
     * 4. 遍历顺序：从上往下 从左往右
     * 4. 举例推导
     **/
    public int change(int amount, int[] coins) {
        int m = coins.length;
        int n = amount;
        int[] dp = new int[n + 1];

        // 初始化第0列
        dp[0] = 1;

        // 循环遍历
        for (int i = 0; i < m; i++) {
            for (int j = coins[i]; j <= n; j++) {
                dp[j] = dp[j] + dp[j - coins[i]];
            }
            // 输出结果
            for (int j = 0; j <= n; j++) {
                System.out.print(dp[j] + " ");
            }
            System.out.println();
        }

        return dp[n];
    }
}
```

### 排列数

#### 二维数组

##### 思路分析

动态规划五部曲：

- dp\[i][j]的含义：第一个放入的物品为物品0-i，恰好装满容量为j的背包方式数

- 递推公式：`dp[i][j] = dp[i - 1][j] + dp[M - 1][j - weight[i]]`

  解析：

  - `dp[i - 1][j]`：第一个放入的物品为物品0-(i-1)，恰好装满容量为j的背包方式数

  - `dp[M - 1][j - weight[i]]`：第一个放入的物品为物品i，恰好装满容量为j的背包的方式数

    ​					`j - weight[i]`代表已经放入了第一个物品(物品i)

    ​					`M - 1`代表剩下的物品可以从物品0-(M-1)任意选择

- 初始化dp\[i][j]：

  由于dp\[i][j]取决于

  - `dp[i - 1][j]`
  - `dp[M - 1][j - weight[i]]`

  因此需要初始化第0行和第0列

  初始化第0行，`dp[0][j] = dp[M - 1][j - weight[i]]`

  初始化第0列，`dp[i][0] = 1`，什么都不放也是一种方式

  其他位置的初始化，默认为0即可，因为不管初始化为什么值都会被`dp[i - 1][j]`和`dp[M - 1][j - weight[i]]`覆盖

  初始化第0行放在遍历到每一列的第一行时再进行即可，此时`dp[M - 1][j - weight[i]]`已知

- 遍历顺序：

  由于`dp[i][j]`取决于

  - `dp[i - 1][j]` 故从上往下遍历。
  - `dp[M - 1][j - weight[i]]` 即第j列的值取决于第`j - weight[i]`列最后一行(M-1)的值，故必须从左往右遍历。且必须先遍历背包再遍历物品才能保证遍历到dp\[i][j]时，`dp[M - 1][j - weight[i]]`的值已经被计算过。
- 举例推导：
  - 背包容量为4

  - 物品的重量：

    | 物品  | 重量 |
    | ----- | ---- |
    | 物品0 | 1    |
    | 物品1 | 2    |
    | 物品2 | 3    |

    递推公式：`dp[i][j] = dp[i - 1][j] + dp[M - 1][j - weight[i]]`

    先遍历背包 后遍历物品

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 2    | 4    |
    | 物品1 | 1    | 1    | 2    | 3    | 6    |
    | 物品2 | 1    | 1    | 2    | 4    | 7    |

##### 代码实现

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

* java

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int m = nums.length;
        int n = target;
        int[][] dp = new int[m][n + 1];
        // 初始化
        // dp[i][0] = 1
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }

        // 循环遍历
        for (int j = 1; j <= n; j++) {
            if (j >= nums[0]) {
                dp[0][j] = dp[m - 1][j - nums[0]];
            }
            for (int i = 1; i < m; i++) {
                if (j >= nums[i]) {
                    dp[i][j] = dp[i - 1][j] + dp[m - 1][j - nums[i]];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // 输出结果
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= n; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }

        return dp[m - 1][n];
    }
}
```

#### 一维数组

##### 思路分析

动规五部曲：

- dp[j]的含义：恰好装满容量为j的背包的方式数

- 递推公式：

  二维数组的递推公式为：

  `dp[i][j] = dp[i - 1][j] + dp[M - 1][j - weight[i]]`

  一维的递推公式为

  `dp[j] = dp[j] + dp[j-weight[i]]`

- 初始化dp[j]：

  dp[j]取决于

  - dp[j]：即初始化为当i==0时，dp[j]的值，此时dp[j] = dp[j-weight[i]]\(原因在二维分析过)，因此dp[j]会被dp[j-weight[i]]覆盖初始化为0即可
  - dp[j-weight[i]]：需要初始化dp[0] = 1，什么都不放是一种方式
- 遍历顺序：

  dp[j]取决于

  - dp[j]---本质上是上一行的dp[j]
  - dp[j-weight[i]]---本质上是最后一行的dp[j-weight[i]]

  因此需要从上往下遍历，从左往右遍历

  且需要先遍历背包 后遍历物品

- 举例推导：
  - 背包容量为4

  - 物品的重量：

    | 物品  | 重量 |
    | ----- | ---- |
    | 物品0 | 1    |
    | 物品1 | 2    |
    | 物品2 | 3    |

    递推公式：`dp[j] = dp[j] + dp[j-weight[i]]`

    先遍历背包 后遍历物品

    |       | 0    | 1    | 2    | 3    | 4    |
    | ----- | ---- | ---- | ---- | ---- | ---- |
    | 物品0 | 1    | 1    | 1    | 2    | 4    |
    | 物品1 | 1    | 1    | 2    | 3    | 6    |
    | 物品2 | 1    | 1    | 2    | 4    | 7    |

##### 代码实现

* java

```java
public int combinationSum4(int[] nums, int target) {
    int m = nums.length;
    int n = target;
    int[] dp = new int[n + 1];

    // 初始化dp
    dp[0] = 1;

    // 循环遍历
    for (int j = 1; j <= n; j++) {
        if (j >= nums[0]) {
            dp[j] = dp[j - nums[0]];
        }
        for (int i = 1; i < m; i++) {
            if (j >= nums[i]) {
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }
    }
    // 输出结果
    for (int j = 0; j <= n; j++) {
        System.out.print(dp[j] + " ");
    }
    System.out.println();

    return dp[n];
}
```


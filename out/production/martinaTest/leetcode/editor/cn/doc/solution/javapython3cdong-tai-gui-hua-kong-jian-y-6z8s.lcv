> [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

[TOC]

# 题目

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

# 题目分析

## 思路分析

这道题是要求给定的三角矩阵，从首行到最后一行的最小路径和。根据题目的转移策略：每一次我们可以从 `(i, j)` 移动到 `(i + 1, j)` 或者 `(i + 1, j + 1)`。**换句话说，我们每个位置 `(i, j)` 可以从 `(i - 1, j)` 和 `(i - 1, j - 1)`** 转移而来。

![image-20240324150858697.png](https://pic.leetcode.cn/1711291149-EqglcZ-image-20240324150858697.png)

设 `minPathSum[i][j]` 表示到达位置 `(i, j)` 时的最小路径和， 因此我们可以得到状态转移方程：`minPathSum[i][j] = triangle[i][j] + min(minPathSum[i - 1][j - 1], minPathSum[i - 1][j])`。最终结果取最后一行每个位置的 `minPathSum[n-1][j]` 的最小值。

特别的，两个边界条件要特殊处理：

- 当 `j = 0`，`j - 1` 时不存在的，因此 `minPathSum[i][0] = triangle[i][0] + minPathSum[i - 1][0]`；
- 当 `j = i`，由于是三角形矩阵，每一行的元素个数都比上一行的多 `1` 个，因此 `triangle[i - 1][i]` 是不存在的，则 `minPathSum[i][i] = triangle[i][i] + minPathSum[i - 1][i - 1]`；

![image-20240324223808603.png](https://pic.leetcode.cn/1711291149-gTQVQz-image-20240324223808603.png)

## 空间优化

由于每次状态转移，我们只用到上一行的 `i - 1` 的数据，因此我们可以将动态数组压缩成一个一维数组，滚动更新。我们定义一个长度为 `n` 的数组来存储当前行每一列的状态值。由于 `minPathSum[j]` 的状态与上一行的 `j - 1` 和 `j` 都有关系，为了避免 `minPathSum[j-`1]` 被覆盖，我们逆序更新状态数组。

![image-20240324145711619.png](https://pic.leetcode.cn/1711291149-EMANqQ-image-20240324145711619.png)

最终数组中存储的就是最后一行每个单元格的状态值。

# 代码

* []

```Java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[] minPathSum = new int[n];      // minPathSum[j] 表示到达当前行位置j的最小路径和
        minPathSum[0] = triangle.get(0).get(0); // 首行只有一个位置，最小路径和为其本身
        // 从第二行开始枚举，第i行就有i列元素
        for(int i = 1; i < n; i++){
            minPathSum[i] = minPathSum[i - 1] + triangle.get(i).get(i); // 第i列的上一行没有不存在，只能从i-1列转移
            // 因为更新第j列需要利用到j-1的数据，因此逆序枚举j避免j-1被覆盖
            for(int j = i - 1; j > 0; j--){
                minPathSum[j] = Math.min(minPathSum[j], minPathSum[j - 1]) + triangle.get(i).get(j);
            }
            minPathSum[0] += triangle.get(i).get(0);    // 首列没有j-1列可以转移，只能从上一行的第j列转移
        }
        // 最终minPathSum存储的是到达最后一行每一列的最小路径和，取最小值即为结果
        int res = Integer.MAX_VALUE;
        for(int ps: minPathSum){
            res = Math.min(ps, res);
        }
        return res;  
    }
}
```

* []

```Python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        min_path_sum = [0] * n      # min_path_sum[j] 表示到达当前行位置j的最小路径和
        min_path_sum[0] = triangle[0][0] # 首行只有一个位置，最小路径和为其本身
        # 从第二行开始枚举，第i行就有i列元素
        for i in range(1, n):
            min_path_sum[i] = min_path_sum[i - 1] + triangle[i][i] # 第i列的上一行没有不存在，只能从i-1列转移
            # 因为更新第j列需要利用到j-1的数据，因此逆序枚举j避免j-1被覆盖
            for j in range(i - 1, 0, -1):
                min_path_sum[j] = min(min_path_sum[j], min_path_sum[j - 1]) + triangle[i][j]
            min_path_sum[0] += triangle[i][0]    # 首列没有j-1列可以转移，只能从上一行的第j列转移

        return min(min_path_sum)  # 最终min_path_sum存储的是到达最后一行每一列的最小路径和，取最小值即为结果
```

* []

```C++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<int> minPathSum(n);      // minPathSum[j] 表示到达当前行位置j的最小路径和
        minPathSum[0] = triangle[0][0]; // 首行只有一个位置，最小路径和为其本身
        // 从第二行开始枚举，第i行就有i列元素
        for(int i = 1; i < n; i++){
            minPathSum[i] = minPathSum[i - 1] + triangle[i][i]; // 第i列的上一行没有不存在，只能从i-1列转移
            // 因为更新第j列需要利用到j-1的数据，因此逆序枚举j避免j-1被覆盖
            for(int j = i - 1; j > 0; j--){
                minPathSum[j] = min(minPathSum[j], minPathSum[j - 1]) + triangle[i][j];
            }
            minPathSum[0] += triangle[i][0];    // 首列没有j-1列可以转移，只能从上一行的第j列转移
        }
        return *min_element(minPathSum.begin(), minPathSum.end());  // 最终minPathSum存储的是到达最后一行每一列的最小路径和，取最小值即为结果
    }
};
```


> Problem: [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/description/)

[TOC]

# 思路

> 对于kknotchill的题解变化

# Code

* []

```Java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        //行
        int m = obstacleGrid.length;
        //列
        int n = obstacleGrid[0].length;
        //dp数组
        int[][] dp = new int[m][n];
        int i,j;

        //如果末位有障碍则永远不可达
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) return 0;
        if (m==1&&n==1&&obstacleGrid[0][0]==0) return 1;

        //初始化最后一列
        // boolean rowMarker = false;
        // for (int i = m - 1; i >= 0; i--) {
        //     //判断滤过了最右下角位
        //     if (obstacleGrid[i][n - 1] == 1 || rowMarker) {
        //         dp[i][n - 1] = 0;
        //         rowMarker = true;
        //     } else {
        //         dp[i][n - 1] = 1;
        //     }
        // }
        //初始化第一行
        boolean rowMarker = false;
        for (i = 1; i < n; i++){
            if (obstacleGrid[0][i] == 1 || rowMarker){
                dp[0][i] = 0;
                //表示从这里开始往右的都为不可达
                rowMarker = true;
            }
            else{
                dp[0][i] = 1;
            }
        }

        //Initialize the last column
        // boolean colMarker = false;
        // for (int j = n - 1; j >= 0; j--) {
        //     if (obstacleGrid[m - 1][j] == 1 || colMarker) {
        //         dp[m - 1][j] = 0;
        //         colMarker = true;
        //     } else {
        //         dp[m - 1][j] = 1;
        //     }
        // }

        //初始化第一列
        boolean colMarker = false;
        for (i = 1; i < m; i++){
            if (obstacleGrid[i][0] == 1 || colMarker){
                dp[i][0] = 0;
                //表示从这里开始往下的都为不可达
                colMarker = true;
            }
            else{
                dp[i][0] = 1;
            }
        }

        //开始判断其他位置
        for (i = 1; i < m; i++){
            for (j = 1; j < n; j++){
                //该位置的上下有一个不为0时就加
                if (obstacleGrid[i][j]!=1 && (dp[i-1][j] != 0 || dp[i][j-1] != 0) ){
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
                else{
                    //否则不通
                    dp[i][j] = 0;
                }
            }
        }

        // for (int i = m - 2; i >= 0; i--) {
        //     for (int j = n - 2; j >= 0; j--) {
        //         if (obstacleGrid[i][j] == 1) {
        //             dp[i][j] = 0;
        //         } else {
        //             dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
        //         }
        //     }
        // }
        return dp[m-1][n-1];
    }
}
```


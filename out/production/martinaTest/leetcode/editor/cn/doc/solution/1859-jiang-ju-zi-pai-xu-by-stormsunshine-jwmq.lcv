# 解法

## 思路和算法

为方便处理，首先将字符串 $s$ 按空格分隔成字符串数组 $\textit{arr}$，得到字符串 $s$ 中的每个单词和单词位置，然后重新构造句子。

新建一个长度等于单词数量的数组 $\textit{sentence}$，对于字符串数组 $\textit{arr}$ 中的每个元素，最后一个字符表示单词位置，其余字符表示单词，用 $\textit{word}$ 表示单词，$\textit{index}$ 表示单词位置，将 $\textit{word}$ 填入 $\textit{sentence}[\textit{index}]$。由于给定的单词位置从 $1$ 开始，但是数组 $\textit{sentence}$ 的下标从 $0$ 开始，因此计算 $\textit{index}$ 时需要做下标转换。

将所有单词填入数组 $\textit{sentence}$ 之后，遍历数组 $\textit{sentence}$ 并按顺序拼接所有单词，单词之间使用一个空格分隔，即可构造得到原本顺序的句子。

## 代码

* [sol1-Java]

```Java
class Solution {
    public String sortSentence(String s) {
        String[] arr = s.split(" ");
        int length = arr.length;
        String[] sentence = new String[length];
        for (int i = 0; i < length; i++) {
            int wordLength = arr[i].length();
            String word = arr[i].substring(0, wordLength - 1);
            int index = arr[i].charAt(wordLength - 1) - '0' - 1;
            sentence[index] = word;
        }
        StringBuffer sb = new StringBuffer();
        for (String word : sentence) {
            if (sb.length() > 0) {
                sb.append(" ");
            }
            sb.append(word);
        }
        return sb.toString();
    }
}
```

* [sol1-C#]

```C#
public class Solution {
    public string SortSentence(string s) {
        string[] arr = s.Split(" ");
        int length = arr.Length;
        string[] sentence = new string[length];
        for (int i = 0; i < length; i++) {
            int wordLength = arr[i].Length;
            string word = arr[i].Substring(0, wordLength - 1);
            int index = arr[i][wordLength - 1] - '0' - 1;
            sentence[index] = word;
        }
        StringBuilder sb = new StringBuilder();
        foreach (string word in sentence) {
            if (sb.Length > 0) {
                sb.Append(" ");
            }
            sb.Append(word);
        }
        return sb.ToString();
    }
}
```

## 复杂度分析

- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。创建字符串数组、遍历每个单词和重新构造句子的时间都是 $O(n)$。

- 空间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。字符串数组和重新构造句子使用的空间是 $O(n)$。


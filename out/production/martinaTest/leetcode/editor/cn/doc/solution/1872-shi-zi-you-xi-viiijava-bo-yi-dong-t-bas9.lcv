### 解题思路

**关于每轮玩家的得分**。每一轮当前玩家取石头时，其实就是选择一个下标 $x$，然后将 $[0, x]$ 区间内的石头合并成一堆并获得得分；下一轮由对手选择另一个下标 $y$，因为 $[0, x]$ 区间内的石头已经合并成一块，并且要求取走的石头至少为 $2$ 个，因此需要保证 $y \in (x, n)$，再取走 $[0, y]$ 区间内的石头。记 ${\rm prefix}(x)$ 为 $[0, x]$ 中所有石头的分数的和，因此每次选择下标 $x$ 的得分就是 ${\rm prefix}(x)$。
**关于每轮玩家的分差**。$\rm Alice$ 和 $\rm Bob$ 的分数之差为 $({\rm Alice}$ 的分数 $- {\rm Bob}$ 的分数$)$。$\rm Alice$ 的目标是最大化分数差，$\rm Bob$ 的目标是最小化分数差。换言之，二者都希望自己的得分尽可能多于对手的得分，最大化自己与对方的分差。记 ${\rm dp}[i]$ 为当前玩家在 $[i, n)$ 区间内选择下标 $x$ 获得的最优分差。如果当前玩家选择下标 $x = i$，则可以获得的分数为 ${\rm prefix(i)}$，下一轮对手在 $(i, n)$ 内选择下标，分差为 ${\rm dp}[i + 1]$，则本轮玩家的分差应该是 ${\rm dp}[i] = {\rm prefix}(i) - {\rm dp}[i + 1]$；如果本轮玩家选择的下标 $x \in (i, n)$，那么获得的分差应该是 ${\rm dp}[i] = {\rm dp}[i + 1]$。期望本轮自己与下一轮对手的分差尽可能大，也就是取以上两种情况的最大值，因此可以获得**转移方程**为
${\rm dp}[i] = \max({\rm prefix}(i) - {\rm dp}[i + 1], {\rm dp}[i + 1])$
**边界条件**：当 $x = n - 1$ 时，此时游戏将要结束，因此分差就是本轮游戏的得分 ${\rm prefix}(n - 1)$。
因为开始游戏时 $\rm Alice$ 必须要选择 $x > 1$ 个石头，因此 ${\rm dp}[1]$ 就是第一轮游戏的最优分差，即为本题的答案。观察到每轮的 ${\rm dp}[i]$ 都只转移自 ${\rm dp}[i + 1]$，因此我们可以只设置一个变量 $\rm dp$ 来记录当前的得分差。

### 代码实现

* []

```java
class Solution {
    public int stoneGameVIII(int[] stones) {
        int n = stones.length;
        // 求出前缀和。prefix[i + 1] 表示 [0: i] 区间的区间和。每一次取石头的过程其实就是选择一个下标 x，将 [0, x] 合并成一堆，并将 prefix[x + 1] 作为本轮的得分。
        int[] prefix = new int[n + 1];
        for (int i = 1; i <= n; i++)
            prefix[i] = prefix[i - 1] + stones[i - 1];
        // dp[i] 表示当可选择下标 [i: n) 个石头时的分差：如果选择的是下标 i，则当前选手获得 prefix[i + 1]，对手在 [i + 1: n) 的石头内继续，得分差为 dp[i + 1]，则对当前选手而言得分差为 prefix[i + 1] - dp[i + 1]；如果不选择下标 i，则会在 [i + 1, n) 内做选择，dp[i] = dp[i + 1]。取两种情况的最大值作为 dp[i]，转移方程为：dp[i] = max(prefix[i + 1] - dp[i + 1], dp[i + 1])，观察到 dp[i] 只转移自 dp[i + 1]，可以只设立一个变量 dp 表示当前的得分差。
        int dp = prefix[n];
        for (int i = n - 2; i > 0; i--)
            dp = Math.max(prefix[i + 1] - dp, dp);
        return dp;
    }
}
```


## 一、启发思考：寻找子问题

看示例 2，$\textit{nums}=[10,-5,-2,4,0,3],\ k=3$。

我们要解决的问题是：从下标 $0$ 跳到下标 $n-1=5$，经过的所有数字之和最大是多少？

思考「最后一步」发生了什么，有 $3$ 种选择：

- 从 $4$ 跳到 $5$，我们需要知道：从 $0$ 跳到 $4$，经过的所有数字之和最大是多少？
- 从 $3$ 跳到 $5$，我们需要知道：从 $0$ 跳到 $3$，经过的所有数字之和最大是多少？
- 从 $2$ 跳到 $5$，我们需要知道：从 $0$ 跳到 $2$，经过的所有数字之和最大是多少？

由于这 $3$ 种选择，都把原问题变为**和原问题相似的、规模更小的子问题**，所以可以用**递归**解决。

> 注 1：从右往左倒着思考，主要是为了方便把递归翻译成递推。从左往右思考也是可以的。
>
> 注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。

## 二、递归怎么写：状态定义与状态转移方程

因为要解决的问题都形如「从 $0$ 跳到 $i$，经过的所有数字之和最大是多少」，所以定义 $\textit{dfs}(i)$ 表示从 $0$ 跳到 $i$，经过的所有数字之和的最大值。

如果从 $j$ 跳过来，那么有 $\textit{dfs}(i) = \textit{dfs}(j) + \textit{nums}[i]$，其中 $\max(i-k, 0) \le j \le i-1$。

枚举 $j$，取转移来源的最大值，即

$$
\textit{dfs}(i) = \max_{j = \max(i-k, 0)}^{i-1} \textit{dfs}(j) + \textit{nums}[i]
$$

递归边界：$\textit{dfs}(0)=\textit{nums}[0]$。

递归入口：$\textit{dfs}(n-1)$，也就是答案。

* [sol-Python3]

```py
# 会超时的递归代码
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        def dfs(i: int) -> int:
            if i == 0:
                return nums[0]
            return max(dfs(j) for j in range(max(i - k, 0), i)) + nums[i]
        return dfs(len(nums) - 1)
```

* [sol-Java]

```java
// 会超时的递归代码
class Solution {
    public int maxResult(int[] nums, int k) {
        return dfs(nums.length - 1, nums, k);
    }

    private int dfs(int i, int[] nums, int k) {
        if (i == 0) {
            return nums[0];
        }
        int mx = Integer.MIN_VALUE;
        for (int j = Math.max(i - k, 0); j < i; j++) {
            mx = Math.max(mx, dfs(j, nums, k));
        }
        return mx + nums[i];
    }
}
```

* [sol-C++]

```cpp
// 会超时的递归代码
class Solution {
public:
    int maxResult(vector<int> &nums, int k) {
        function<int(int)> dfs = [&](int i) -> int {
            if (i == 0) {
                return nums[0];
            }
            int mx = INT_MIN;
            for (int j = max(i - k, 0); j < i; j++) {
                mx = max(mx, dfs(j));
            }
            return mx + nums[i];
        };
        return dfs(nums.size() - 1);
    }
};
```

* [sol-Go]

```go
// 会超时的递归代码
func maxResult(nums []int, k int) int {
    var dfs func(i int) int
    dfs = func(i int) int {
        if i == 0 {
            return nums[0]
        }
        mx := math.MinInt
        for j := max(i-k, 0); j < i; j++ {
            mx = max(mx, dfs(j))
        }
        return mx + nums[i]
    }
    return dfs(len(nums) - 1)
}
```

* [sol-JavaScript]

```js
// 会超时的递归代码
var maxResult = function(nums, k) {
    function dfs(i) {
        if (i === 0) {
            return nums[0];
        }
        let mx = -Infinity;
        for (let j = Math.max(i - k, 0); j < i; j++) {
            mx = Math.max(mx, dfs(j));
        }
        return mx + nums[i];
    }
    return dfs(nums.length - 1);
};
```

* [sol-Rust]

```rust
// 会超时的递归代码
impl Solution {
    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {
        fn dfs(i: usize, nums: &Vec<i32>, k: usize) -> i32 {
            if i == 0 {
                return nums[0];
            }
            let mut mx = i32::MIN;
            for j in i.saturating_sub(k)..i {
                mx = mx.max(dfs(j, nums, k));
            }
            mx + nums[i]
        }
        dfs(nums.len() - 1, &nums, k as usize)
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(k^n)$，其中 $n$ 分别为 $\textit{nums}$ 的长度。搜索树可以近似为一棵 $k$ 叉树，树高为 $\mathcal{O}(n)$，所以节点个数为 $\mathcal{O}(k^n)$，遍历搜索树需要 $\mathcal{O}(k^n)$ 的时间。
- 空间复杂度：$\mathcal{O}(n)$。递归需要 $\mathcal{O}(n)$ 的栈空间。

## 三、1:1 翻译成递推

我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。

具体来说，$f[i]$ 的定义和 $\textit{dfs}(i)$ 的定义是一样的，都表示从 $0$ 跳到 $i$，经过的所有数字之和的最大值。

相应的递推式（状态转移方程）也和 $\textit{dfs}$ 一样：

$$
f[i] = \max_{j = \max(i-k, 0)}^{i-1} f[j] + \textit{nums}[i]
$$

> 相当于之前是用递归去计算每个状态，现在是**枚举**并计算每个状态。

初始值 $f[0]=\textit{nums}[0]$，翻译自递归边界 $\textit{dfs}(0)=\textit{nums}[0]$。

答案为 $f[n-1]$，翻译自递归入口 $\textit{dfs}(n-1)$。

* [sol-Python3]

```py
# 超时，需要进一步优化
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        f = [0] * n
        f[0] = nums[0]
        for i in range(1, n):
            f[i] = max(f[max(i - k, 0): i]) + nums[i]
        return f[-1]
```

* [sol-Java]

```java
// 超时，需要进一步优化
class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        int[] f = new int[n];
        f[0] = nums[0];
        for (int i = 1; i < n; i++) {
            int mx = Integer.MIN_VALUE;
            for (int j = Math.max(i - k, 0); j < i; j++) {
                mx = Math.max(mx, f[j]);
            }
            f[i] = mx + nums[i];
        }
        return f[n - 1];
    }
}
```

* [sol-C++]

```cpp
// 超时，需要进一步优化
class Solution {
public:
    int maxResult(vector<int> &nums, int k) {
        int n = nums.size();
        vector<int> f(n);
        f[0] = nums[0];
        for (int i = 1; i < n; i++) {
            f[i] = *max_element(f.begin() + max(i - k, 0), f.begin() + i) + nums[i];
        }
        return f[n - 1];
    }
};
```

* [sol-Go]

```go
// 超时，需要进一步优化
func maxResult(nums []int, k int) int {
    n := len(nums)
    f := make([]int, n)
    f[0] = nums[0]
    for i := 1; i < n; i++ {
        f[i] = slices.Max(f[max(i-k, 0):i]) + nums[i]
    }
    return f[n-1]
}
```

* [sol-JavaScript]

```js
// 超时，需要进一步优化
var maxResult = function(nums, k) {
    const n = nums.length;
    const f = Array(n);
    f[0] = nums[0];
    for (let i = 1; i < n; i++) {
        f[i] = Math.max(...f.slice(Math.max(i - k, 0), i)) + nums[i];
    }
    return f[n - 1];
};
```

* [sol-Rust]

```rust
// 超时，需要进一步优化
impl Solution {
    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let k = k as usize;
        let mut f = vec![0; n];
        f[0] = nums[0];
        for i in 1..n {
            f[i] = f[i.saturating_sub(k)..i].iter().max().unwrap() + nums[i];
        }
        f[n - 1]
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(nk)$，其中 $n$ 分别为 $\textit{nums}$ 的长度。
- 空间复杂度：$\mathcal{O}(n)$。

## 四、单调队列优化

当 $i<k$ 时，我们计算的是 $f[0],f[1],\cdots,f[i-1]$ 的最大值。

当 $i\ge k$ 时，我们计算的是 $f[i-k],f[i-k+1],\cdots,f[i-1]$ 的最大值。这是一个长度固定为 $k$ 的 [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) 问题，我在 [单调队列【基础算法精讲 27】](https://www.bilibili.com/video/BV1bM411X72E/)中讲了如何解决。

对于本题，我们维护一个 $f$ 值从左到右严格递减的单调队列（双端队列）。在计算 $f[i]$ 时，需要**保证队首就是转移来源最大值的下标**，方法如下：

1. **出**：如果队首小于 $i-k$，则弹出队首。注意单调队列只需保存下标。
2. **转移**：$f[i] = f[q[0]] + \textit{nums}[i]$。其中 $q[0]$ 表示单调队列 $q$ 的队首，此时队首就是转移来源最大值的下标。
3. **入**：不断弹出队尾，直到队列为空，或者 $f[i]$ 小于队尾对应的 $f$ 值为止。然后把 $i$ 加到队尾。

* [sol-Python3]

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        f = [0] * n
        f[0] = nums[0]
        q = deque([0])
        for i in range(1, n):
            # 1. 出
            if q[0] < i - k:
                q.popleft()
            # 2. 转移
            f[i] = f[q[0]] + nums[i]
            # 3. 入
            while q and f[i] >= f[q[-1]]:
                q.pop()
            q.append(i)
        return f[-1]
```

* [sol-Java]

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        int[] f = new int[n];
        f[0] = nums[0];
        Deque<Integer> q = new ArrayDeque<>();
        q.add(0);
        for (int i = 1; i < n; i++) {
            // 1. 出
            if (q.peekFirst() < i - k) {
                q.pollFirst();
            }
            // 2. 转移
            f[i] = f[q.peekFirst()] + nums[i];
            // 3. 入
            while (!q.isEmpty() && f[i] >= f[q.peekLast()]) {
                q.pollLast();
            }
            q.add(i);
        }
        return f[n - 1];
    }
}
```

* [sol-C++]

```cpp
class Solution {
public:
    int maxResult(vector<int> &nums, int k) {
        int n = nums.size();
        vector<int> f(n);
        f[0] = nums[0];
        deque<int> q = {0};
        for (int i = 1; i < n; i++) {
            // 1. 出
            if (q.front() < i - k) {
                q.pop_front();
            }
            // 2. 转移
            f[i] = f[q.front()] + nums[i];
            // 3. 入
            while (!q.empty() && f[i] >= f[q.back()]) {
                q.pop_back();
            }
            q.push_back(i);
        }
        return f[n - 1];
    }
};
```

* [sol-Go]

```go
func maxResult(nums []int, k int) int {
    n := len(nums)
    f := make([]int, n)
    f[0] = nums[0]
    q := []int{0}
    for i := 1; i < n; i++ {
        // 1. 出
        if q[0] < i-k {
            q = q[1:]
        }
        // 2. 转移
        f[i] = f[q[0]] + nums[i]
        // 3. 入
        for len(q) > 0 && f[i] >= f[q[len(q)-1]] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
    }
    return f[n-1]
}
```

* [sol-JavaScript]

```js
var maxResult = function(nums, k) {
    const n = nums.length;
    const f = Array(n);
    f[0] = nums[0];
    const q = Array(n);
    let rear = 0, tail = 0;
    q[tail++] = 0;
    for (let i = 1; i < n; i++) {
        // 1. 出
        if (q[rear] < i - k) {
            rear++;
        }
        // 2. 转移
        f[i] = f[q[rear]] + nums[i];
        // 3. 入
        while (rear < tail && f[i] >= f[q[tail - 1]]) {
            tail--;
        }
        q[tail++] = i;
    }
    return f[n - 1];
};
```

* [sol-Rust]

```rust
use std::collections::VecDeque;

impl Solution {
    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let k = k as usize;
        let mut f = vec![0; n];
        f[0] = nums[0];
        let mut q = VecDeque::new();
        q.push_back(0);
        for i in 1..n {
            // 1. 出
            if *q.front().unwrap() + k < i {
                q.pop_front();
            }
            // 2. 转移
            f[i] = f[*q.front().unwrap()] + nums[i];
            // 3. 入
            while !q.is_empty() && f[i] >= f[*q.back().unwrap()] {
                q.pop_back();
            }
            q.push_back(i);
        }
        f[n - 1]
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 分别为 $\textit{nums}$ 的长度。虽然我们写了个二重循环，但由于每个下标入队出队各至多一次，所以二重循环的循环次数是 $\mathcal{O}(n)$ 的。
- 空间复杂度：$\mathcal{O}(n)$。

## 五、空间优化

把 $f[i]$ 直接记在 $\textit{nums}$ 中，这样就只需要 $\mathcal{O}(k)$ 的额外空间。

> 注：如果不想修改 $\textit{nums}[i]$，也可以把数对 $(i,f[i])$ 保存到单调队列中。

* [sol-Python3]

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        q = deque([0])
        for i in range(1, len(nums)):
            # 1. 出
            if q[0] < i - k:
                q.popleft()
            # 2. 转移
            nums[i] += nums[q[0]]
            # 3. 入
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
        return nums[-1]
```

* [sol-Java]

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> q = new ArrayDeque<>();
        q.add(0);
        for (int i = 1; i < n; i++) {
            // 1. 出
            if (q.peekFirst() < i - k) {
                q.pollFirst();
            }
            // 2. 转移
            nums[i] += nums[q.peekFirst()];
            // 3. 入
            while (!q.isEmpty() && nums[i] >= nums[q.peekLast()]) {
                q.pollLast();
            }
            q.add(i);
        }
        return nums[n - 1];
    }
}
```

* [sol-C++]

```cpp
class Solution {
public:
    int maxResult(vector<int> &nums, int k) {
        deque<int> q = {0};
        for (int i = 1; i < nums.size(); i++) {
            // 1. 出
            if (q.front() < i - k) {
                q.pop_front();
            }
            // 2. 转移
            nums[i] += nums[q.front()];
            // 3. 入
            while (!q.empty() && nums[i] >= nums[q.back()]) {
                q.pop_back();
            }
            q.push_back(i);
        }
        return nums.back();
    }
};
```

* [sol-Go]

```go
func maxResult(nums []int, k int) int {
    n := len(nums)
    q := []int{0}
    for i := 1; i < n; i++ {
        // 1. 出
        if q[0] < i-k {
            q = q[1:]
        }
        // 2. 转移
        nums[i] += nums[q[0]]
        // 3. 入
        for len(q) > 0 && nums[i] >= nums[q[len(q)-1]] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
    }
    return nums[n-1]
}
```

* [sol-JavaScript]

```js
var maxResult = function(nums, k) {
    const n = nums.length;
    const q = Array(n); // 为方便起见，仍然用一个大小为 n 的数组（空间 O(k) 需要实现环形队列）
    let rear = 0, tail = 0;
    q[tail++] = 0;
    for (let i = 1; i < n; i++) {
        // 1. 出
        if (q[rear] < i - k) {
            rear++;
        }
        // 2. 转移
        nums[i] += nums[q[rear]];
        // 3. 入
        while (rear < tail && nums[i] >= nums[q[tail - 1]]) {
            tail--;
        }
        q[tail++] = i;
    }
    return nums[n - 1];
};
```

* [sol-Rust]

```rust
use std::collections::VecDeque;

impl Solution {
    pub fn max_result(mut nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let k = k as usize;
        let mut q = VecDeque::new();
        q.push_back(0);
        for i in 1..n {
            // 1. 出
            if *q.front().unwrap() + k < i {
                q.pop_front();
            }
            // 2. 转移
            nums[i] += nums[*q.front().unwrap()];
            // 3. 入
            while !q.is_empty() && nums[i] >= nums[*q.back().unwrap()] {
                q.pop_back();
            }
            q.push_back(i);
        }
        nums[n - 1]
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$，其中 $n$ 分别为 $\textit{nums}$ 的长度。虽然我们写了个二重循环，但由于每个下标入队出队各至多一次，所以二重循环的循环次数是 $\mathcal{O}(n)$ 的。
- 空间复杂度：$\mathcal{O}(k)$。单调队列需要 $\mathcal{O}(k)$ 的空间。

## 思考题

把 $k$ 改成一个数组 $\textit{jumpLimits}$，其中 $\textit{jumpLimits}[i]$ 表示从下标 $i$ 处向右跳，至多可以跳 $\textit{jumpLimits}[i]$ 步。

如此修改后，应该怎么做呢？

欢迎在评论区分享你的思路/代码。

## 练习：单调队列

- [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
- [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) 1672
- [2398. 预算内的最多机器人数目](https://leetcode.cn/problems/maximum-number-of-robots-within-budget/) 1917
- [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/) 2307
- [1499. 满足不等式的最大值](https://leetcode.cn/problems/max-value-of-equation/) 2456

## 练习：单调队列优化 DP

- [2944. 购买水果需要的最少金币数](https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/) 1709 可以用单调队列优化到 $\mathcal{O}(n)$
- [1425. 带限制的子序列和](https://leetcode.cn/problems/constrained-subsequence-sum/) 2032
- [375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/) 可以用单调队列优化到 $\mathcal{O}(n^2)$
- [1687. 从仓库到码头运输箱子](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/) 2610
- [2945. 找到最大非递减数组的长度](https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/) 2943

更多 DP 题解，请看 [往期题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

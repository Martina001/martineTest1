#### 方法一：双层循环

**思路**

题目要求返回所有交替子数组的最长长度，我们可以利用双层循环。外层的循环遍历数组每一个的下标，使其作为交替子数组的第一个下标 $\textit{firstIndex}$ 。内层循环则从 $\textit{firstIndex}$ 往后遍历，判断接下来的元素是否满足交替子数组的条件。是的话则更新最长长度，不满足的的话则跳出内层循环，继续外层循环。外层循环遍历完后，返回最长长度。

**代码**

* [sol1-Python3]

```Python
class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        res = -1
        n = len(nums)
        for firstIndex in range(n):
            for i in range(firstIndex + 1, n):
                length = i - firstIndex + 1
                if nums[i] - nums[firstIndex] == (length - 1) % 2:
                    res = max(res, length)
                else:
                    break
        return res
```

* [sol1-Java]

```Java
class Solution {
    public int alternatingSubarray(int[] nums) {
        int res = -1;
        int n = nums.length;
        for (int firstIndex = 0; firstIndex < n; firstIndex++) {
            for (int i = firstIndex + 1; i < n; i++) {
                int length = i - firstIndex + 1;
                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                    res = Math.max(res, length);
                } else {
                    break;
                }
            }
        }
        return res;
    }
}
```

* [sol1-C#]

```C#
public class Solution {
    public int AlternatingSubarray(int[] nums) {
        int res = -1;
        int n = nums.Length;
        for (int firstIndex = 0; firstIndex < n; firstIndex++) {
            for (int i = firstIndex + 1; i < n; i++) {
                int length = i - firstIndex + 1;
                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                    res = Math.Max(res, length);
                } else {
                    break;
                }
            }
        }
        return res;
    }
}
```

* [sol1-C++]

```C++
class Solution {
public:
    int alternatingSubarray(vector<int>& nums) {
        int res = -1;
        int n = nums.size();
        for (int firstIndex = 0; firstIndex < n; firstIndex++) {
            for (int i = firstIndex + 1; i < n; i++) {
                int length = i - firstIndex + 1;
                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                    res = max(res, length);
                } else {
                    break;
                }
            }
        }
        return res;
    }
};
```

* [sol1-C]

```C
int alternatingSubarray(int* nums, int numsSize) {
    int res = -1;
    for (int firstIndex = 0; firstIndex < numsSize; firstIndex++) {
        for (int i = firstIndex + 1; i < numsSize; i++) {
            int length = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                res = fmax(res, length);
            } else {
                break;
            }
        }
    }
    return res;
}
```

* [sol1-Go]

```Go
func alternatingSubarray(nums []int) int {
    res := -1
    n := len(nums)
    for firstIndex := 0; firstIndex < n; firstIndex++ {
        for i := firstIndex + 1; i < n; i++ {
            length := i - firstIndex + 1
            if nums[i] - nums[firstIndex] == (length - 1) % 2 {
                res = max(res, length)
            } else {
                break
            }
        }
    }
    return res
}
```

* [sol1-JavaScript]

```JavaScript
var alternatingSubarray = function(nums) {
    let res = -1;
    const n = nums.length;
    for (let firstIndex = 0; firstIndex < n; firstIndex++) {
        for (let i = firstIndex + 1; i < n; i++) {
            const length = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] === (length - 1) % 2) {
                res = Math.max(res, length);
            } else {
                break;
            }
        }
    }

    return res;
};
```

* [sol1-TypeScript]

```TypeScript
function alternatingSubarray(nums: number[]): number {
    let res: number = -1;
    const n: number = nums.length;
    for (let firstIndex: number = 0; firstIndex < n; firstIndex++) {
        for (let i: number = firstIndex + 1; i < n; i++) {
            const length: number = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] === (length - 1) % 2) {
                res = Math.max(res, length);
            } else {
                break;
            }
        }
    }

    return res;
};
```

* [sol1-Rust]

```Rust
impl Solution {
    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {
        let mut res = -1;
        let n = nums.len();
        for first_index in 0..n {
            for i in (first_index + 1)..n {
                let length = i - first_index + 1;
                if nums[i] - nums[first_index] == (length - 1) as i32 % 2 {
                    res = res.max(length as i32);
                } else {
                    break;
                }
            }
        }
        res
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$。其中 $n$ 是数组 $\textit{nums}$ 的长度，我们需要双层循环。

- 空间复杂度：$O(1)$。

#### 方法二：单层循环

**思路**

方法一比较直观，但是复杂度比较高。当内层循环判断出当前下标 $i$ 打破了交替子数组的条件后，我们其实不需要回到外层循环的下标 $\textit{firstIndex}$，因为通过内层循环，我们已经知道子数组 $\textit{nums}[\textit{firstIndex},\dots,i-1]$ 是满足交替子数组的条件的。分析以下情况：
* 如果这个子数组的长度大于等于 $3$，那么我们不需要从 $\textit{firstIndex}+1$ 开始外层循环，因为子数组 $\textit{nums}[\textit{firstIndex+1}, \textit{firstIndex+2}]$ 必不满足交替子数组。
* 如果这个子数组的长度大于等于 $4$，那么我们不需要从 $\textit{firstIndex}+2$ 开始外层循环，因为子数组 $\textit{nums}[\textit{firstIndex+2},\dots,i-1]$ 虽然满足交替子数组，但是这个交替数组会在 $i$ 被破环，并且长度小于 $\textit{nums}[\textit{firstIndex},\dots,i-1]$。

通过这样分析，我们可以得出结论，外层的循环可以从 $i-1$ 继续。而这样的话，我们可以丢弃外层循环，在内层循环多做一个 $\textit{firstIndex}$ 是否可以为 $i-1$ 的判断，而只保留内层循环。如果可以，则将 $\textit{firstIndex}$ 更新为 $i-1$，并更新最长长度。如果不可以，则将 $\textit{firstIndex}$ 更新为 $i$。两种情况下，内层循环下一个遍历的下标都为 $i+1$，这样，我们就只用循环一层，即可以在循环结束后返回结果。

**代码**

* [sol2-Python3]

```Python
class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        res = -1
        firstIndex = 0
        for i in range(1, len(nums)):
            length = i - firstIndex + 1
            if nums[i] - nums[firstIndex] == (length - 1) % 2:
                res = max(res, length)
            else:
                if nums[i] - nums[i - 1] == 1:
                    firstIndex = i - 1
                    res = max(res, 2)
                else:
                    firstIndex = i
        return res
```

* [sol2-Java]

```Java
class Solution {
    public int alternatingSubarray(int[] nums) {
        int res = -1;
        int n = nums.length;
        int firstIndex = 0;
        for (int i = 1; i < n; i++) {
            int length = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                res = Math.max(res, length);
            } else {
                if (nums[i] - nums[i - 1] == 1) {
                    firstIndex = i - 1;
                    res = Math.max(res, 2);
                } else {
                    firstIndex = i;
                }
            }
        }
        return res;
    }
}
```

* [sol2-C#]

```C#
public class Solution {
    public int AlternatingSubarray(int[] nums) {
        int res = -1;
        int n = nums.Length;
        int firstIndex = 0;
        for (int i = 1; i < n; i++) {
            int length = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                res = Math.Max(res, length);
            } else {
                if (nums[i] - nums[i - 1] == 1) {
                    firstIndex = i - 1;
                    res = Math.Max(res, 2);
                } else {
                    firstIndex = i;
                }
            }
        }
        return res;
    }
}
```

* [sol2-C++]

```C++
class Solution {
public:
    int alternatingSubarray(vector<int>& nums) {
        int res = -1;
        int n = nums.size();
        int firstIndex = 0;
        for (int i = 1; i < n; i++) {
            int length = i - firstIndex + 1;
            if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
                res = max(res, length);
            } else {
                if (nums[i] - nums[i - 1] == 1) {
                    firstIndex = i - 1;
                    res = max(res, 2);
                } else {
                    firstIndex = i;
                }
            }
        }
        return res;
    }
};
```

* [sol2-C]

```C
int alternatingSubarray(int* nums, int numsSize) {
    int res = -1;
    int firstIndex = 0;
    for (int i = 1; i < numsSize; i++) {
        int length = i - firstIndex + 1;
        if (nums[i] - nums[firstIndex] == (length - 1) % 2) {
            res = fmax(res, length);
        } else {
            if (nums[i] - nums[i - 1] == 1) {
                firstIndex = i - 1;
                res = fmax(res, 2);
            } else {
                firstIndex = i;
            }
        }
    }

    return res;
}
```

* [sol2-Go]

```Go
func alternatingSubarray(nums []int) int {
    res := -1
    n := len(nums)
    firstIndex := 0
    for i := 1; i < n; i++ {
        length := i - firstIndex + 1
        if nums[i] - nums[firstIndex] == (length - 1) % 2 {
            res = max(res, length)
        } else {
            if nums[i] - nums[i - 1] == 1 {
                firstIndex = i - 1
                res = max(res, 2)
            } else {
                firstIndex = i
            }
        }
    }
    return res
}
```

* [sol2-JavaScript]

```JavaScript
var alternatingSubarray = function(nums) {
    let res = -1;
    const n = nums.length;
    let firstIndex = 0;

    for (let i = 1; i < n; i++) {
        const length = i - firstIndex + 1;
        if (nums[i] - nums[firstIndex] === (length - 1) % 2) {
            res = Math.max(res, length);
        } else {
            if (nums[i] - nums[i - 1] === 1) {
                firstIndex = i - 1;
                res = Math.max(res, 2);
            } else {
                firstIndex = i;
            }
        }
    }
    return res;
};
```

* [sol2-TypeScript]

```TypeScript
function alternatingSubarray(nums: number[]): number {
    let res = -1;
    const n = nums.length;
    let firstIndex = 0;
    for (let i = 1; i < n; i++) {
        const length = i - firstIndex + 1;
        if (nums[i] - nums[firstIndex] === (length - 1) % 2) {
            res = Math.max(res, length);
        } else {
            if (nums[i] - nums[i - 1] === 1) {
                firstIndex = i - 1;
                res = Math.max(res, 2);
            } else {
                firstIndex = i;
            }
        }
    }
    return res;
};
```

* [sol2-Rust]

```Rust
impl Solution {
    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {
        let mut res = -1;
        let mut first_index = 0;
        let n = nums.len();
        for i in 1..n {
            let length = i - first_index + 1;
            if nums[i] - nums[first_index] == (length - 1) as i32 % 2 {
                res = res.max(length as i32);
            } else {
                if nums[i] - nums[i - 1] == 1 {
                    first_index = i - 1;
                    res = res.max(2);
                } else {
                    first_index = i;
                }
            }
        }
        res
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。其中 $n$ 是数组 $\textit{nums}$ 的长度，我们只需要单层循环。

- 空间复杂度：$O(1)$。


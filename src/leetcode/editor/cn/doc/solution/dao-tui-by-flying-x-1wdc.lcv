> Problem: [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

[TOC]

# 思路

> 倒推法，从后往前遍历一遍数组，如果从某点开始到第一个数都不能到达该位置，说明该点不可达。

# 解题方法

> 令n = nums.length
> 1.当n == 1时，起点即终点返回true。
> 2.当n > 1时,从nums[n-2]开始从后向前遍历数组，判断能否到达数组的位置k（初始位置为n-1），并用step记录步长。如果当前的位置k可达，则重置步长为0，直到下一个不可达点重新记录位置k。
> 3.使用count记录不可达的数量，如果从nums[k-1]直到nums[0]都不可达nums[k]点，则返回false，否则返回true。

# 复杂度

时间复杂度:

> 时间复杂度,  $O(n)$

空间复杂度:

> 空间复杂度,  $O(1)$

# Code

* []

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return true;
        }
        int step=0;
        int count=0,k=n-1,j=0;
        for(int i=n-2; i>=0; i--){
            step++;
            if(nums[i]-step >= 0){
                step=0;
                count=0;
                j=0;
            }
            else{
                if(j==0){
                    k=i+1;
                    j=1;
                }
                count++;
            }
        }
        if(count == k){
            return false;
        }
        else{
            return true;
        }
    }
}
```


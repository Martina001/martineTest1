# 解法一

## 思路和算法

由于每一轮 Bob 从 Alice 分成的两个非空行中丢弃一行，因此剩余的石子一定是数组 $\textit{stoneValue}$ 中的连续子数组，可以使用开始下标和结束下标表示子数组。剩余石子值之和为一个子数组的元素值之和，对于 $i \le j$，用 $\textit{sum}(i, j)$ 表示数组 $\textit{stoneValue}$ 的下标范围 $[i, j]$ 的子数组的元素值之和。

为了快速计算数组 $\textit{stoneValue}$ 的子数组的元素值之和，需要预计算数组 $\textit{stoneValue}$ 的前缀和数组。用 $n$ 表示数组 $\textit{stoneValue}$ 的长度。创建长度为 $n + 1$ 的数组 $\textit{prefixSums}$，其中 $\textit{prefixSums}[0] = 0$，对于 $0 \le i < n$ 有 $\textit{prefixSums}[i + 1] = \textit{prefixSums}[i] + \textit{stoneValue}[i]$。计算前缀和数组之后，有如下结论。

1. 对于 $0 \le i \le n$，$\textit{prefixSums}[i]$ 为数组 $\textit{stoneValue}$ 的长度为 $i$ 的前缀的元素值之和。

2. 对于 $0 \le i \le j < n$，数组 $\textit{stoneValue}$ 的下标范围 $[i, j]$ 的子数组的元素值之和为 $\textit{prefixSums}[j + 1] - \textit{prefixSums}[i]$。

每一轮之后，都会有一个非空子数组被丢弃，因此剩余行对应更短的子数组，可以使用动态规划计算 Alice 能够获得的最大分数。

创建 $n \times n$ 的二维数组 $\textit{dp}$，其中 $\textit{dp}[i][j]$ 为区间 $[i, j]$ 中 Alice 能够获得的最大分数。

当 $i = j$ 时，子数组中只有一个石子，为游戏结束的状态，Alice 能够获得的最大分数是 $0$，因此动态规划的边界情况是：对于 $0 \le i < n$，$\textit{dp}[i][i] = 0$。

当 $i < j$ 时，Alice 可以选择 $i \le k < j$ 的任意下标 $k$，将区间 $[i, j]$ 分成左区间 $[i, k]$ 和右区间 $[k + 1, j]$，Bob 会丢弃值最大的区间，Alice 的分数增加剩余区间的元素和。当 Alice 选择下标 $k$ 时，区间 $[i, j]$ 的分数如下。

- 如果 $\textit{sum}(i, k) < \textit{sum}(k + 1, j)$，则剩余区间是 $[i, k]$，区间 $[i, j]$ 的分数是 $\textit{sum}(i, k) + \textit{dp}[i][k]$。

- 如果 $\textit{sum}(i, k) > \textit{sum}(k + 1, j)$，则剩余区间是 $[k + 1, j]$，区间 $[i, j]$ 的分数是 $\textit{sum}(k + 1, j) + \textit{dp}[k + 1][j]$。

- 如果 $\textit{sum}(i, k) = \textit{sum}(k + 1, j)$，则 Alice 选择分数更大的区间，区间 $[i, j]$ 的分数是 $\max(\textit{sum}(i, k) + \textit{dp}[i][k], \textit{sum}(k + 1, j) + \textit{dp}[k + 1][j])$。

用 $\textit{score}(i, j, k)$ 表示在区间 $[i, j]$ 中 Alice 选择下标 $k$ 时的最大分数。为了使区间 $[i, j]$ 的分数最大化，Alice 应选择使 $\textit{score}(i, j, k)$ 的下标 $k$，因此动态规划的状态转移方程是：对于所有 $i \le k < j$，$\textit{dp}[i][j] = \max\{\textit{score}(i, j, k)\}$。

根据动态规划的状态转移方程，计算 $\textit{dp}[i][j]$ 需要使用 $\textit{dp}[i][k]$ 和 $\textit{dp}[k + 1][j]$ 的值，即区间 $[i, k]$ 和 $[k + 1, j]$ 的状态值需要在区间 $[i, j]$ 的状态值之前计算，因此计算 $\textit{dp}[i][j]$ 的顺序可以是以下两种。

1. 从小到大遍历每个区间长度，对于每个区间长度依次计算每个区间的状态值。

2. 从大到小遍历每个区间开始下标 $i$，对于每个区间开始下标 $i$ 从小到大遍历每个区间结束下标 $j$，依次计算每个区间 $[i, j]$ 的状态值。

计算得到 $\textit{dp}[0][n - 1]$ 即为 Alice 能够获得的最大分数。

## 代码

下面的代码为按照区间长度递增顺序计算的实现。

* [sol1_1-Java]

```Java
class Solution {
    public int stoneGameV(int[] stoneValue) {
        int n = stoneValue.length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] dp = new int[n][n];
        for (int subLength = 2; subLength <= n; subLength++) {
            for (int i = 0, j = subLength - 1; j < n; i++, j++) {
                int score = 0;
                for (int k = i; k < j; k++) {
                    int leftSum = getRangeSum(prefixSums, i, k), rightSum = getRangeSum(prefixSums, k + 1, j);
                    if (leftSum < rightSum) {
                        score = Math.max(score, leftSum + dp[i][k]);
                    } else if (leftSum > rightSum) {
                        score = Math.max(score, rightSum + dp[k + 1][j]);
                    } else {
                        score = Math.max(score, Math.max(leftSum + dp[i][k], rightSum + dp[k + 1][j]));
                    }
                }
                dp[i][j] = score;
            }
        }
        return dp[0][n - 1];
    }

    public int getRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

* [sol1_1-C#]

```C#
public class Solution {
    public int StoneGameV(int[] stoneValue) {
        int n = stoneValue.Length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] dp = new int[n][];
        for (int i = 0; i < n; i++) {
            dp[i] = new int[n];
        }
        for (int subLength = 2; subLength <= n; subLength++) {
            for (int i = 0, j = subLength - 1; j < n; i++, j++) {
                int score = 0;
                for (int k = i; k < j; k++) {
                    int leftSum = GetRangeSum(prefixSums, i, k), rightSum = GetRangeSum(prefixSums, k + 1, j);
                    if (leftSum < rightSum) {
                        score = Math.Max(score, leftSum + dp[i][k]);
                    } else if (leftSum > rightSum) {
                        score = Math.Max(score, rightSum + dp[k + 1][j]);
                    } else {
                        score = Math.Max(score, Math.Max(leftSum + dp[i][k], rightSum + dp[k + 1][j]));
                    }
                }
                dp[i][j] = score;
            }
        }
        return dp[0][n - 1];
    }

    public int GetRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

下面的代码为按照区间开始下标递减顺序计算的实现。

* [sol1_2-Java]

```Java
class Solution {
    public int stoneGameV(int[] stoneValue) {
        int n = stoneValue.length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] dp = new int[n][n];
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                int score = 0;
                for (int k = i; k < j; k++) {
                    int leftSum = getRangeSum(prefixSums, i, k), rightSum = getRangeSum(prefixSums, k + 1, j);
                    if (leftSum < rightSum) {
                        score = Math.max(score, leftSum + dp[i][k]);
                    } else if (leftSum > rightSum) {
                        score = Math.max(score, rightSum + dp[k + 1][j]);
                    } else {
                        score = Math.max(score, Math.max(leftSum + dp[i][k], rightSum + dp[k + 1][j]));
                    }
                }
                dp[i][j] = score;
            }
        }
        return dp[0][n - 1];
    }

    public int getRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

* [sol1_2-C#]

```C#
public class Solution {
    public int StoneGameV(int[] stoneValue) {
        int n = stoneValue.Length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] dp = new int[n][];
        for (int i = 0; i < n; i++) {
            dp[i] = new int[n];
        }
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                int score = 0;
                for (int k = i; k < j; k++) {
                    int leftSum = GetRangeSum(prefixSums, i, k), rightSum = GetRangeSum(prefixSums, k + 1, j);
                    if (leftSum < rightSum) {
                        score = Math.Max(score, leftSum + dp[i][k]);
                    } else if (leftSum > rightSum) {
                        score = Math.Max(score, rightSum + dp[k + 1][j]);
                    } else {
                        score = Math.Max(score, Math.Max(leftSum + dp[i][k], rightSum + dp[k + 1][j]));
                    }
                }
                dp[i][j] = score;
            }
        }
        return dp[0][n - 1];
    }

    public int GetRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

## 复杂度分析

- 时间复杂度：$O(n^3)$，其中 $n$ 是数组 $\textit{stoneValue}$ 的长度。计算前缀和数组的时间是 $O(n)$，动态规划的状态数是 $O(n^2)$，每个状态的计算时间是 $O(n)$，因此时间复杂度是 $O(n^3)$。

- 空间复杂度：$O(n^2)$，其中 $n$ 是数组 $\textit{stoneValue}$ 的长度。需要创建长度为 $n + 1$ 的前缀和数组 $\textit{prefixSums}$ 与大小为 $n \times n$ 的二维数组 $\textit{dp}$。

# 解法二

## 思路和算法

用 $n$ 表示数组 $\textit{stoneValue}$ 的长度。解法一在计算 $\textit{dp}[i][j]$ 时需要遍历 $i \le k < j$ 的所有下标 $k$，因此计算每个状态的时间是 $O(n)$，时间复杂度是 $O(n^3)$。如果可以降低计算每个状态的时间，则可以降低时间复杂度。

此处沿用解法一的表示法，用 $\textit{sum}(i, j)$ 表示数组 $\textit{stoneValue}$ 的下标范围 $[i, j]$ 的子数组的元素值之和，用 $\textit{score}(i, j, k)$ 表示在区间 $[i, j]$ 中 Alice 选择下标 $k$ 时的最大分数。

由于数组 $\textit{stoneValue}$ 的元素值都是正整数，因此对于任意非空区间 $[i, j]$，其中 $0 \le i \le j < n$，一定存在一个最小的下标 $\textit{halfPoint}$ 满足区间 $[i, \textit{halfPoint}]$ 的元素和大于等于区间 $[\textit{halfPoint} + 1, j]$ 的元素和，将下标 $\textit{halfPoint}$ 称为区间 $[i, j]$ 的中间点。中间点一定满足 $i \le \textit{halfPoint} \le j$，当 $\textit{halfPoint} = j$ 时区间 $[\textit{halfPoint} + 1, j]$ 的元素和为 $0$。由于当 $i < \textit{halfPoint}$ 时区间 $[i, \textit{halfPoint}]$ 的元素和为 $0$，一定小于区间 $[\textit{halfPoint} + 1, j]$ 的元素和，因此必有 $\textit{halfPoint} \ge i$。

中间点的定义的另一种等价表述是：非空区间 $[i, j]$ 的中间点 $\textit{halfPoint}$ 是满足区间 $[i, \textit{halfPoint}]$ 的元素和大于等于区间 $[i, j]$ 的元素和的一半的最小下标。对于 $i \le j_1 < j_2$，区间 $[i, j_2]$ 的元素和一定大于区间 $[i, j_1]$ 的元素和，因此区间 $[i, j_2]$ 的中间点一定大于等于区间 $[i, j_1]$ 的中间点。由此可以得到，当区间的左端下标 $i$ 固定时，从左到右遍历区间的右端下标 $j$，每次将右端下标 $j$ 向右移动时，区间的中间点不变或向右移动，因此对于特定左端下标 $i$，可以使用 $O(n)$ 的时间计算其对应的所有区间的中间点，计算数组 $\textit{stoneValue}$ 的所有区间的中间点的时间是 $O(n^2)$。

创建 $n \times n$ 的二维数组 $\textit{halfPoints}$，其中 $\textit{halfPoints}[i][j]$ 为区间 $[i, j]$ 的中间点。

得到所有区间的中间点之后，$\textit{score}(i, j, k)$ 计算如下。

- 当 $k < \textit{halfPoints}[i][j]$ 时，$\textit{score}(i, j, k) = \textit{sum}(i, k) + \textit{dp}[i][k]$。

- 当 $k \ge \textit{halfPoints}[i][j]$ 时，$\textit{score}(i, j, k) = \textit{sum}(k + 1, j) + \textit{dp}[k + 1][j]$。

为了降低时间复杂度，不能遍历 $i \le k < j$ 的所有下标 $k$，而是需要维护每个区间的区间和与状态值之和的最大值。

创建 $n \times n$ 的二维数组 $\textit{dpLeft}$ 和 $\textit{dpRight}$，其中 $\textit{dpLeft}[i][j]$ 为区间 $[i, j]$ 的前缀区间的区间和与状态值之和的最大值，$\textit{dpRight}[i][j]$ 为区间 $[i, j]$ 的后缀区间的区间和与状态值之和的最大值，正式的表示如下：对于所有 $i \le k \le j$，$\textit{dpLeft}[i][j] = \max\{\textit{sum}(i, k) + \textit{dp}[i][k]\}$，$\textit{dpRight}[i][j] = \max\{\textit{sum}(k, j) + \textit{dp}[k][j]\}$。边界情况是：当 $i > j$ 时，$\textit{dpLeft}[i][j] = \textit{dpRight}[i][j] = 0$。

当 $i \le j$ 时，$\textit{dpLeft}$ 和 $\textit{dpRight}$ 的状态转移方程是：$\textit{dpLeft}[i][j] = \max(\textit{dpLeft}[i][j - 1], \sum(i, j) + \textit{dp}[i][j])$，$\textit{dpRight}[i][j] = \max(\textit{dpLeft}[i + 1][j], \sum(i, j) + \textit{dp}[i][j])$。根据状态转移方程，$\textit{dpLeft}$ 和 $\textit{dpRight}$ 的每个状态可以使用 $O(1)$ 的时间计算，且一定有 $\textit{dpLeft}[i][j] \ge \textit{dpLeft}[i][j - 1]$ 和 $\textit{dpRight}[i][j] \ge \textit{dpRight}[i + 1][j]$。

当 $i \le j$ 时，使用优化的方法计算状态值 $\textit{dp}[i][j]$ 的做法如下。

1. 得到区间 $[i, j]$ 的中间点 $k = \textit{halfPoints}[i][j]$。

2. 中间点 $k$ 将区间 $[i, j]$ 分成左区间 $[i, k]$ 和右区间 $[k + 1, j]$，得到左区间 $[i, k]$ 的元素和 $\textit{leftSum}$ 与右区间 $[k + 1, j]$ 的元素和 $\textit{rightSum}$。根据中间点的定义，$\textit{leftSum} \ge \textit{rightSum}$。

3. 比较 $\textit{leftSum}$ 与 $\textit{rightSum}$ 的大小，执行如下操作。

   - 如果 $\textit{leftSum} = \textit{rightSum}$，则区间 $[i, j]$ 可以分成两个元素和相等的区间。为了获得最大分数，应考虑两个区间的最大分数，因此 $\textit{dp}[i][j] = \max(\textit{dpLeft}[i][k], \textit{dpRight}[k + 1][j])$。

   - 如果 $\textit{leftSum} > \textit{rightSum}$，则可能剩余的元素和最大的左区间是 $[i, k - 1]$，可能剩余的元素和最大的右区间是 $[k + 1, j]$，分别对应分数 $\textit{dpLeft}[i][k - 1]$ 与 $\textit{dpRight}[k + 1][j]$。由于当 $p < k - 1$ 时必有 $\textit{dpLeft}[i][p] \le \textit{dpLeft}[i][k - 1]$，当 $p > k + 1$ 时必有 $\textit{dpRight}[p][j] \le \textit{dpRight}[k + 1][j]$，因此为了获得最大分数，应考虑区间 $[i, k - 1]$ 与 $[k + 1, j]$ 的最大分数，因此 $\textit{dp}[i][j] = \max(\textit{dpLeft}[i][k - 1], \textit{dpRight}[k + 1][j])$。特别地，当 $i > k - 1$ 时 $\textit{dpLeft}[i][k - 1] = 0$，当 $k + 1 > j$ 时 $\textit{dpRight}[k + 1][j] = 0$。
4. 计算 $\textit{nextScore} = \sum(i, j) + \textit{dp}[i][j]$，则 $\textit{nextScore}$ 为从一个更大区间到达区间 $[i, j]$ 的分数。

5. 根据 $i$ 与 $j$ 的大小关系，计算 $\textit{dpLeft}[i][j]$ 与 $\textit{dpRight}[i][j]$。
   - 如果 $i = j$，则 $\textit{dpLeft}[i][j] = \textit{dpRight}[i][j] = \textit{nextScore}$。

   - 如果 $i < j$，则 $\textit{dpLeft}[i][j] = \max(\textit{dpLeft}[i][j - 1], \textit{nextScore})$，$\textit{dpRight}[i][j] = \max(\textit{dpRight}[i + 1][j], \textit{nextScore})$。

计算各区间的顺序可以是以下两种。

1. 从小到大遍历每个区间长度，对于每个区间长度依次计算每个区间的状态值。

2. 从大到小遍历每个区间开始下标 $i$，对于每个区间开始下标 $i$ 从小到大遍历每个区间结束下标 $j$，依次计算每个区间 $[i, j]$ 的状态值。

计算得到 $\textit{dp}[0][n - 1]$ 即为 Alice 能够获得的最大分数。

## 代码

下面的代码为按照区间长度递增顺序计算的实现。

* [sol2_1-Java]

```Java
class Solution {
    public int stoneGameV(int[] stoneValue) {
        int n = stoneValue.length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] halfPoints = new int[n][n];
        for (int i = 0; i < n; i++) {
            int leftSum = 0, totalSum = 0;
            for (int j = i, k = i - 1; j < n; j++) {
                totalSum += stoneValue[j];
                while (leftSum < totalSum - leftSum) {
                    k++;
                    leftSum += stoneValue[k];
                }
                halfPoints[i][j] = k;
            }
        }
        int[][] dp = new int[n][n];
        int[][] dpLeft = new int[n][n];
        int[][] dpRight = new int[n][n];
        for (int subLength = 1; subLength <= n; subLength++) {
            for (int i = 0, j = subLength - 1; j < n; i++, j++) {
                int k = halfPoints[i][j];
                int leftSum = getRangeSum(prefixSums, i, k), rightSum = getRangeSum(prefixSums, k + 1, j);
                if (leftSum == rightSum) {
                    dp[i][j] = Math.max(dpLeft[i][k], dpRight[k + 1][j]);
                } else {
                    int leftScore = i <= k - 1 ? dpLeft[i][k - 1] : 0;
                    int rightScore = k + 1 <= j ? dpRight[k + 1][j] : 0;
                    dp[i][j] = Math.max(leftScore, rightScore);
                }
                int nextScore = getRangeSum(prefixSums, i, j) + dp[i][j];
                if (i == j) {
                    dpLeft[i][j] = nextScore;
                    dpRight[i][j] = nextScore;
                } else {
                    dpLeft[i][j] = Math.max(dpLeft[i][j - 1], nextScore);
                    dpRight[i][j] = Math.max(dpRight[i + 1][j], nextScore);
                }
            }
        }
        return dp[0][n - 1];
    }

    public int getRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

* [sol2_1-C#]

```C#
public class Solution {
    public int StoneGameV(int[] stoneValue) {
        int n = stoneValue.Length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] halfPoints = new int[n][];
        for (int i = 0; i < n; i++) {
            halfPoints[i] = new int[n];
            int leftSum = 0, totalSum = 0;
            for (int j = i, k = i - 1; j < n; j++) {
                totalSum += stoneValue[j];
                while (leftSum < totalSum - leftSum) {
                    k++;
                    leftSum += stoneValue[k];
                }
                halfPoints[i][j] = k;
            }
        }
        int[][] dp = new int[n][];
        int[][] dpLeft = new int[n][];
        int[][] dpRight = new int[n][];
        for (int i = 0; i < n; i++) {
            dp[i] = new int[n];
            dpLeft[i] = new int[n];
            dpRight[i] = new int[n];
        }
        for (int subLength = 1; subLength <= n; subLength++) {
            for (int i = 0, j = subLength - 1; j < n; i++, j++) {
                int k = halfPoints[i][j];
                int leftSum = GetRangeSum(prefixSums, i, k), rightSum = GetRangeSum(prefixSums, k + 1, j);
                if (leftSum == rightSum) {
                    dp[i][j] = Math.Max(dpLeft[i][k], dpRight[k + 1][j]);
                } else {
                    int leftScore = i <= k - 1 ? dpLeft[i][k - 1] : 0;
                    int rightScore = k + 1 <= j ? dpRight[k + 1][j] : 0;
                    dp[i][j] = Math.Max(leftScore, rightScore);
                }
                int nextScore = GetRangeSum(prefixSums, i, j) + dp[i][j];
                if (i == j) {
                    dpLeft[i][j] = nextScore;
                    dpRight[i][j] = nextScore;
                } else {
                    dpLeft[i][j] = Math.Max(dpLeft[i][j - 1], nextScore);
                    dpRight[i][j] = Math.Max(dpRight[i + 1][j], nextScore);
                }
            }
        }
        return dp[0][n - 1];
    }

    public int GetRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

下面的代码为按照区间开始下标递减顺序计算的实现。

* [sol2_2-Java]

```Java
class Solution {
    public int stoneGameV(int[] stoneValue) {
        int n = stoneValue.length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] halfPoints = new int[n][n];
        for (int i = 0; i < n; i++) {
            int leftSum = 0, totalSum = 0;
            for (int j = i, k = i - 1; j < n; j++) {
                totalSum += stoneValue[j];
                while (leftSum < totalSum - leftSum) {
                    k++;
                    leftSum += stoneValue[k];
                }
                halfPoints[i][j] = k;
            }
        }
        int[][] dp = new int[n][n];
        int[][] dpLeft = new int[n][n];
        int[][] dpRight = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                int k = halfPoints[i][j];
                int leftSum = getRangeSum(prefixSums, i, k), rightSum = getRangeSum(prefixSums, k + 1, j);
                if (leftSum == rightSum) {
                    dp[i][j] = Math.max(dpLeft[i][k], dpRight[k + 1][j]);
                } else {
                    int leftScore = i <= k - 1 ? dpLeft[i][k - 1] : 0;
                    int rightScore = k + 1 <= j ? dpRight[k + 1][j] : 0;
                    dp[i][j] = Math.max(leftScore, rightScore);
                }
                int nextScore = getRangeSum(prefixSums, i, j) + dp[i][j];
                if (i == j) {
                    dpLeft[i][j] = nextScore;
                    dpRight[i][j] = nextScore;
                } else {
                    dpLeft[i][j] = Math.max(dpLeft[i][j - 1], nextScore);
                    dpRight[i][j] = Math.max(dpRight[i + 1][j], nextScore);
                }
            }
        }
        return dp[0][n - 1];
    }

    public int getRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

* [sol2_2-C#]

```C#
public class Solution {
    public int StoneGameV(int[] stoneValue) {
        int n = stoneValue.Length;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + stoneValue[i];
        }
        int[][] halfPoints = new int[n][];
        for (int i = 0; i < n; i++) {
            halfPoints[i] = new int[n];
            int leftSum = 0, totalSum = 0;
            for (int j = i, k = i - 1; j < n; j++) {
                totalSum += stoneValue[j];
                while (leftSum < totalSum - leftSum) {
                    k++;
                    leftSum += stoneValue[k];
                }
                halfPoints[i][j] = k;
            }
        }
        int[][] dp = new int[n][];
        int[][] dpLeft = new int[n][];
        int[][] dpRight = new int[n][];
        for (int i = 0; i < n; i++) {
            dp[i] = new int[n];
            dpLeft[i] = new int[n];
            dpRight[i] = new int[n];
        }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                int k = halfPoints[i][j];
                int leftSum = GetRangeSum(prefixSums, i, k), rightSum = GetRangeSum(prefixSums, k + 1, j);
                if (leftSum == rightSum) {
                    dp[i][j] = Math.Max(dpLeft[i][k], dpRight[k + 1][j]);
                } else {
                    int leftScore = i <= k - 1 ? dpLeft[i][k - 1] : 0;
                    int rightScore = k + 1 <= j ? dpRight[k + 1][j] : 0;
                    dp[i][j] = Math.Max(leftScore, rightScore);
                }
                int nextScore = GetRangeSum(prefixSums, i, j) + dp[i][j];
                if (i == j) {
                    dpLeft[i][j] = nextScore;
                    dpRight[i][j] = nextScore;
                } else {
                    dpLeft[i][j] = Math.Max(dpLeft[i][j - 1], nextScore);
                    dpRight[i][j] = Math.Max(dpRight[i + 1][j], nextScore);
                }
            }
        }
        return dp[0][n - 1];
    }

    public int GetRangeSum(int[] prefixSums, int start, int end) {
        return prefixSums[end + 1] - prefixSums[start];
    }
}
```

## 复杂度分析

- 时间复杂度：$O(n^2)$，其中 $n$ 是数组 $\textit{stoneValue}$ 的长度。计算前缀和数组的时间是 $O(n)$，计算中间点的时间是 $O(n^2)$，动态规划的状态数是 $O(n^2)$，每个状态的计算时间是 $O(1)$，因此时间复杂度是 $O(n^2)$。

- 空间复杂度：$O(n^2)$，其中 $n$ 是数组 $\textit{stoneValue}$ 的长度。需要创建长度为 $n + 1$ 的前缀和数组 $\textit{prefixSums}$ 以及大小为 $n \times n$ 的二维数组 $\textit{halfPoints}$、$\textit{dp}$、$\textit{dpLeft}$ 和 $\textit{dpRight}$。


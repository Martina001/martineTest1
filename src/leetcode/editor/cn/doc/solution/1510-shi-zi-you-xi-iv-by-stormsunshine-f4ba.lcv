# 解法

## 思路和算法

根据游戏规则，每一轮都会将石子数量减少。当没有剩余的石子时，玩家无法执行操作。当还有剩余的石子时，玩家可以执行操作。

可以使用动态规划计算结果。创建长度为 $n + 1$ 的数组 $\textit{dp}$，其中 $\textit{dp}[i]$ 为剩余 $i$ 个石子时当前玩家的游戏结果，$\text{true}$ 表示当前玩家获胜，$\text{false}$ 表示当前玩家失败。

当 $i = 0$ 时，轮到的玩家无法执行操作而输掉游戏，因此动态规划的边界情况是 $\textit{dp}[0] = \text{false}$。

当 $i > 0$ 时，当前玩家可以选择任意不超过 $i$ 的完全平方数 $j$，取走 $j$ 个石子，剩余 $i - j$ 个石子。如果存在一个不超过 $i$ 的完全平方数 $j$ 满足 $\textit{dp}[i - j] = \text{false}$，则当前玩家可以取走 $j$ 个石子使对方玩家失败，因此当前玩家获胜；如果所有不超过 $i$ 的完全平方数 $j$ 都满足 $\textit{dp}[i - j] = \text{true}$，则当前玩家失败。

因此动态规划的状态转移方程是：如果存在一个不超过 $i$ 的完全平方数 $j$ 满足 $\textit{dp}[i - j] = \text{false}$，则 $\textit{dp}[i] = \text{true}$；如果所有不超过 $i$ 的完全平方数 $j$ 都满足 $\textit{dp}[i - j] = \text{true}$，则 $\textit{dp}[i] = \text{false}$。

根据动态规划的状态转移方程，计算 $\textit{dp}[i]$ 的顺序为从到大小遍历每个 $i$。计算得到 $\textit{dp}[n]$ 即为游戏结果。

## 代码

* [sol1-Java]

```Java
class Solution {
    public boolean winnerSquareGame(int n) {
        boolean[] dp = new boolean[n + 1];
        for (int i = 1; i <= n; i++) {
            boolean flag = false;
            for (int j = 1; j * j <= i && !flag; j++) {
                if (!dp[i - j * j]) {
                    flag = true;
                }
            }
            dp[i] = flag;
        }
        return dp[n];
    }
}
```

* [sol1-C#]

```C#
public class Solution {
    public bool WinnerSquareGame(int n) {
        bool[] dp = new bool[n + 1];
        for (int i = 1; i <= n; i++) {
            bool flag = false;
            for (int j = 1; j * j <= i && !flag; j++) {
                if (!dp[i - j * j]) {
                    flag = true;
                }
            }
            dp[i] = flag;
        }
        return dp[n];
    }
}
```

## 复杂度分析

- 时间复杂度：$O(n \sqrt{n})$，其中 $n$ 是初始的石子数量。动态规划的状态数是 $O(n)$，每个状态的计算时间是 $O(\sqrt{n})$，因此时间复杂度是 $O(n \sqrt{n})$。

- 空间复杂度：$O(n)$，其中 $n$ 是初始的石子数量。需要创建长度为 $n + 1$ 的数组 $\textit{dp}$。

